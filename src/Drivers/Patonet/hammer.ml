
let hammer =
"/*! Hammer.JS - v1.0.0 - 2013-02-26\n* http://eightmedia.github.com/hammer.js\n*\n* Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;\n* Licensed under the MIT license */\n\n(function(window) {\n    'use strict';\n\n/**\n* Hammer\n* use this to create instances\n* @param {HTMLElement} element\n* @param {Object} options\n* @returns {Hammer.Instance}\n* @constructor\n*/\nvar Hammer = function(element, options) {\n    return new Hammer.Instance(element, options || {});\n};\n\n// default settings\nHammer.defaults = {\n    // add styles and attributes to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling, but cancels\n    // the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: {\n        userSelect: 'none', // this also triggers onselectstart=false for IE\n        touchCallout: 'none',\n        touchAction: 'none',\n        contentZooming: 'none',\n        userDrag: 'none',\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n\n    // more settings are defined per gesture at gestures.js\n};\n\n// detect touchevents\nHammer.HAS_POINTEREVENTS = navigator.msPointerEnabled;\nHammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n// eventtypes per touchevent (start, move, end)\n// are filled by Hammer.event.determineEventTypes on setup\nHammer.EVENT_TYPES = {};\n\n// direction defines\nHammer.DIRECTION_DOWN = 'down';\nHammer.DIRECTION_LEFT = 'left';\nHammer.DIRECTION_UP = 'up';\nHammer.DIRECTION_RIGHT = 'right';\n\n// pointer type\nHammer.POINTER_MOUSE = 'mouse';\nHammer.POINTER_TOUCH = 'touch';\n\n// touch event defines\nHammer.EVENT_START = 'start';\nHammer.EVENT_MOVE = 'move';\nHammer.EVENT_END = 'end';\n\n// plugins namespace\nHammer.plugins = {};\n\n// if the window events are set...\nHammer.READY = false;\n\n/**\n* setup events to detect gestures on the document\n*/\nfunction setup() {\n    if(Hammer.READY) {\n        return;\n    }\n\n    // find what eventtypes we add listeners to\n    Hammer.event.determineEventTypes();\n\n    // Register all gestures inside Hammer.gestures\n    for(var name in Hammer.gestures) {\n        if(Hammer.gestures.hasOwnProperty(name)) {\n            Hammer.detection.register(Hammer.gestures[name]);\n        }\n    }\n\n    // Add touch events on the window\n    Hammer.event.onTouch(document, Hammer.EVENT_MOVE, Hammer.detection.detect);\n    Hammer.event.onTouch(document, Hammer.EVENT_END, Hammer.detection.endDetect);\n\n    // Hammer is ready...!\n    Hammer.READY = true;\n}\n\n/**\n* create new hammer instance\n* all methods should return the instance itself, so it is chainable.\n* @param {HTMLElement} element\n* @param {Object} [options={}]\n* @returns {Hammer.Instance}\n* @constructor\n*/\nHammer.Instance = function(element, options) {\n    var self = this;\n\n    // setup HammerJS window events and register all gestures\n    // this also sets up the default options\n    setup();\n\n    this.element = element;\n\n    // start/stop detection option\n    this.enabled = true;\n\n    // merge options\n    this.options = Hammer.utils.extend(\n        Hammer.utils.extend({}, Hammer.defaults),\n        options || {});\n\n    // add some css to the element to prevent the browser from doing its native behavoir\n    if(this.options.stop_browser_behavior) {\n        Hammer.utils.stopDefaultBrowserBehavior(this);\n    }\n\n    // start detection on touchstart\n    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {\n        if(self.enabled) {\n            Hammer.detection.startDetect(self, ev);\n        }\n    });\n\n    // return instance\n    return this;\n};\n\n\nHammer.Instance.prototype = {\n    /**\n* bind events to the instance\n* @param {String} gesture\n* @param {Function} handler\n* @returns {Hammer.Instance}\n*/\n    on: function onEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.addEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n* unbind events to the instance\n* @param {String} gesture\n* @param {Function} handler\n* @returns {Hammer.Instance}\n*/\n    off: function offEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.removeEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n* trigger gesture event\n* @param {String} gesture\n* @param {Object} eventData\n* @returns {Hammer.Instance}\n*/\n    trigger: function triggerEvent(gesture, eventData){\n        // trigger DOM event\n        var event = document.createEvent('Event');\nevent.initEvent(gesture, true, true);\nevent.gesture = eventData;\nthis.element.dispatchEvent(event);\n        return this;\n    },\n\n\n    /**\n* enable of disable hammer.js detection\n* @param {Boolean} state\n* @returns {Hammer.Instance}\n*/\n    enable: function enable(state) {\n        this.enabled = state;\n        return this;\n    }\n};\n\n/**\n* this holds the last move event,\n* used to fix empty touchend issue\n* see the onTouch event for an explanation\n* @type {Object}\n*/\nvar last_move_event = null;\n\n\n/**\n* when the mouse is hold down, this is true\n* @type {Boolean}\n*/\nvar enable_detect = false;\n\n\n/**\n* when touch events have been fired, this is true\n* @type {Boolean}\n*/\nvar touch_triggered = false;\n\n\nHammer.event = {\n    /**\n* simple addEventListener\n* @param {HTMLElement} element\n* @param {String} type\n* @param {Function} handler\n*/\n    bindDom: function(element, type, handler) {\n        var types = type.split(' ');\n        for(var t=0; t<types.length; t++) {\n            element.addEventListener(types[t], handler, false);\n        }\n    },\n\n\n    /**\n* touch events with mouse fallback\n* @param {HTMLElement} element\n* @param {String} eventType like Hammer.EVENT_MOVE\n* @param {Function} handler\n*/\n    onTouch: function onTouch(element, eventType, handler) {\nvar self = this;\n        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function(ev) {\n            var sourceEventType = ev.type.toLowerCase();\n\n            // mousebutton must be down or a touch event\n            if(sourceEventType.match(/start|down|move/) &&\n                ( ev.which === 1 || // mousedown\n                    sourceEventType.match(/touch/) || // touch events are always on screen\n                    (ev.pointerType && ev.pointerType == ev.MSPOINTER_TYPE_TOUCH) // pointerevents touch\n                )) {\n                enable_detect = true;\n            }\n\n            // we are in a touch event, set the touch triggered bool to true,\n            // this for the conflicts that may occur on ios and android\n            if(sourceEventType.match(/touch|pointer/)) {\n                touch_triggered = true;\n            }\n\n            // when touch has been triggered in this detection session\n            // and we are now handling a mouse event, we stop that to prevent conflicts\n            if(enable_detect && !(touch_triggered && sourceEventType.match(/mouse/))) {\n                // update pointer\n                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {\n                    Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n\n                // because touchend has no touches, and we often want to use these in our gestures,\n                // we send the last move event as our eventData in touchend\n                if(eventType === Hammer.EVENT_END && last_move_event !== null) {\n                    ev = last_move_event;\n                }\n                // store the last move event\n                else {\n                    last_move_event = ev;\n                }\n\n                // trigger the handler\n                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));\n\n                // remove pointer after the handler is done\n                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {\n                    Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n            }\n\n            // on the end we reset everything\n            if(sourceEventType.match(/up|cancel|end/)) {\n                enable_detect = false;\n                touch_triggered = false;\n                Hammer.PointerEvent.reset();\n            }\n        });\n    },\n\n\n    /**\n* we have different events for each device/browser\n* determine what we need and set them in the Hammer.EVENT_TYPES constant\n*/\n    determineEventTypes: function determineEventTypes() {\n        // determine the eventtype we want to set\n        var types;\n        if(Hammer.HAS_POINTEREVENTS) {\n            types = [\n                'MSPointerDown',\n                'MSPointerMove',\n                'MSPointerUp MSPointerCancel'\n            ];\n        }\n        // for non pointer events browsers\n        else {\n            types = [\n                'touchstart mousedown',\n                'touchmove mousemove',\n                'touchend touchcancel mouseup'];\n        }\n\n        Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];\n        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];\n        Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];\n    },\n\n\n    /**\n* create touchlist depending on the event\n* @param {Object} ev\n* @param {String} eventType used by the fakemultitouch plugin\n*/\n    getTouchList: function getTouchList(ev/*, eventType*/) {\n        // get the fake pointerEvent touchlist\n        if(Hammer.HAS_POINTEREVENTS) {\n            return Hammer.PointerEvent.getTouchList();\n        }\n        // get the touchlist\n        else if(ev.touches) {\n            return ev.touches;\n        }\n        // make fake touchlist from mouse position\n        else {\n            return [{\n                identifier: 1,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                target: ev.target\n            }];\n        }\n    },\n\n\n    /**\n* collect event data for Hammer js\n* @param {HTMLElement} element\n* @param {String} eventType like Hammer.EVENT_MOVE\n* @param {Object} eventData\n*/\n    collectEventData: function collectEventData(element, eventType, ev) {\n        var touches = this.getTouchList(ev, eventType);\n\n        // find out pointerType\n        var pointerType = Hammer.POINTER_TOUCH;\n        if(ev.type.match(/mouse/) || (ev.poinerType && ev.pointerType === ev.MSPOINTER_TYPE_MOUSE)) {\n            pointerType = Hammer.POINTER_MOUSE;\n        }\n\n        return {\n            center : Hammer.utils.getCenter(touches),\n            timestamp : ev.timestamp || new Date().getTime(), // for IE\n            target : ev.target,\n            touches : touches,\n            eventType : eventType,\n            pointerType : pointerType,\n            srcEvent : ev,\n\n            /**\n* prevent the browser default actions\n* mostly used to disable scrolling of the browser\n*/\n            preventDefault: function() {\n                if(this.srcEvent.preventManipulation) {\n                    this.srcEvent.preventManipulation();\n                }\n\n                if(this.srcEvent.preventDefault) {\n                    this.srcEvent.preventDefault();\n                }\n            },\n\n            /**\n* stop bubbling the event up to its parents\n*/\n            stopPropagation: function() {\n                this.srcEvent.stopPropagation();\n            },\n\n            /**\n* immediately stop gesture detection\n* might be useful after a swipe was detected\n* @return {*}\n*/\n            stopDetect: function() {\n                return Hammer.detection.stopDetect();\n            }\n        };\n    }\n};\n\nHammer.PointerEvent = {\n    /**\n* holds all pointers\n* @type {Object}\n*/\n    pointers: {},\n\n    /**\n* get a list of pointers\n* @returns {Array} touchlist\n*/\n    getTouchList: function() {\n        var pointers = this.pointers;\n        var touchlist = [];\n\n        // we can use forEach since pointerEvents only is in IE10\n        Object.keys(pointers).sort().forEach(function(id) {\n            touchlist.push(pointers[id]);\n        });\n        return touchlist;\n    },\n\n    /**\n* update the position of a pointer\n* @param {String} type\n* @param {Object} pointerEvent\n*/\n    updatePointer: function(type, pointerEvent) {\n        if(type == Hammer.EVENT_END) {\n            delete this.pointers[pointerEvent.pointerId];\n        }\n        else {\n            pointerEvent.identifier = pointerEvent.pointerId;\n            this.pointers[pointerEvent.pointerId] = pointerEvent;\n        }\n    },\n\n    /**\n* reset the list\n*/\n    reset: function() {\n        this.pointers = {};\n    }\n};\n\nHammer.utils = {\n    /**\n* extend method,\n* also used for cloning when dest is an empty object\n* @param {Object} dest\n* @param {Object} src\n* @returns {Object} dest\n*/\n    extend: function extend(dest, src) {\n        for (var key in src) {\n            dest[key] = src[key];\n        }\n\n        return dest;\n    },\n\n\n    /**\n* get the center of all the touches\n* @param {Array} touches\n* @returns {Object} center\n*/\n    getCenter: function getCenter(touches) {\n        var valuesX = [], valuesY = [];\n\n        for(var t= 0,len=touches.length; t<len; t++) {\n            valuesX.push(touches[t].pageX);\n            valuesY.push(touches[t].pageY);\n        }\n\n        return {\n            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),\n            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)\n        };\n    },\n\n\n    /**\n* calculate the velocity between two points\n* @param {Number} delta_time\n* @param {Number} delta_x\n* @param {Number} delta_y\n* @returns {Object} velocity\n*/\n    getVelocity: function getSimpleDistance(delta_time, delta_x, delta_y) {\n        return {\n            x: Math.abs(delta_x / delta_time) || 0,\n            y: Math.abs(delta_y / delta_time) || 0\n        };\n    },\n\n\n    /**\n* calculate the angle between two coordinates\n* @param {Touch} touch1\n* @param {Touch} touch2\n* @returns {Number} angle\n*/\n    getAngle: function getAngle(touch1, touch2) {\n        var y = touch2.pageY - touch1.pageY,\n            x = touch2.pageX - touch1.pageX;\n        return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n\n    /**\n* angle to direction define\n* @param {Touch} touch1\n* @param {Touch} touch2\n* @returns {String} direction constant, like Hammer.DIRECTION_LEFT\n*/\n    getDirection: function getDirection(touch1, touch2) {\n        var x = Math.abs(touch1.pageX - touch2.pageX),\n            y = Math.abs(touch1.pageY - touch2.pageY);\n\n        if(x >= y) {\n            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n        }\n        else {\n            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n        }\n    },\n\n\n    /**\n* calculate the distance between two touches\n* @param {Touch} touch1\n* @param {Touch} touch2\n* @returns {Number} distance\n*/\n    getDistance: function getDistance(touch1, touch2) {\n        var x = touch2.pageX - touch1.pageX,\n            y = touch2.pageY - touch1.pageY;\n        return Math.sqrt((x*x) + (y*y));\n    },\n\n\n    /**\n* calculate the scale factor between two touchLists (fingers)\n* no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n* @param {Array} start\n* @param {Array} end\n* @returns {Number} scale\n*/\n    getScale: function getScale(start, end) {\n        // need two fingers...\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getDistance(end[0], end[1]) /\n                this.getDistance(start[0], start[1]);\n        }\n        return 1;\n    },\n\n\n    /**\n* calculate the rotation degrees between two touchLists (fingers)\n* @param {Array} start\n* @param {Array} end\n* @returns {Number} rotation\n*/\n    getRotation: function getRotation(start, end) {\n        // need two fingers\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getAngle(end[1], end[0]) -\n                this.getAngle(start[1], start[0]);\n        }\n        return 0;\n    },\n\n\n    /**\n* boolean if the direction is vertical\n* @param {String} direction\n* @returns {Boolean} is_vertical\n*/\n    isVertical: function isVertical(direction) {\n        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);\n    },\n\n\n    /**\n* stop browser default behavior with css props\n* @param {Hammer.Instance} inst\n*/\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(inst) {\n        var prop,\n            vendors = ['webkit','khtml','moz','ms','o',''],\n            css_props = inst.options.stop_browser_behavior;\n\n        if(!css_props) {\n            return;\n        }\n\n        // with css properties for modern browsers\n        for(var i = 0; i < vendors.length; i++) {\n            for(var p in css_props) {\n                if(css_props.hasOwnProperty(p)) {\n                    prop = p;\n                    if(vendors[i]) {\n                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n                    }\n                    inst.element.style[prop] = css_props[p];\n                }\n            }\n        }\n\n        // also the disable onselectstart\n        if(css_props.userSelect == 'none') {\n            inst.element.onselectstart = function() {\n                return false;\n            };\n        }\n    }\n};\n\nHammer.detection = {\n    // contains all registred Hammer.gestures in the correct order\n    gestures: [],\n\n    // data of the current Hammer.gesture detection session\n    current: null,\n\n    // the previous Hammer.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n\n    /**\n* start Hammer.gesture detection\n* @param {Hammer.Instance} inst\n* @param {Object} eventData\n*/\n    startDetect: function startDetect(inst, eventData) {\n        // already busy with a Hammer.gesture detection on an element\n        if(this.current) {\n            return;\n        }\n\n        this.stopped = false;\n\n        this.current = {\n            inst : inst, // reference to HammerInstance we're working for\n            startEvent : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc\n            lastEvent : false, // last eventData\n            name : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n        };\n\n        this.detect(eventData);\n    },\n\n\n    /**\n* Hammer.gesture detection\n* @param {Object} eventData\n*/\n    detect: function detect(eventData) {\n        if(!this.current || this.stopped) {\n            return;\n        }\n\n        // extend event data with calculations about scale, distance etc\n        eventData = this.extendEventData(eventData);\n\n        // instance options\n        var inst_options = this.current.inst.options;\n\n        // call Hammer.gesture handlers\n        for(var g=0,len=this.gestures.length; g<len; g++) {\n            var gesture = this.gestures[g];\n\n            // only when the instance options have enabled this gesture\n            if(!this.stopped && inst_options[gesture.name] !== false) {\n                // if a handler returns false, we stop with the detection\n                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n                    this.stopDetect();\n                    break;\n                }\n            }\n        }\n\n        // store as previous event event\n        if(this.current) {\n            this.current.lastEvent = eventData;\n        }\n    },\n\n\n    /**\n* end Hammer.gesture detection\n* @param {Object} eventData\n*/\n    endDetect: function endDetect(eventData) {\n        this.detect(eventData);\n        this.stopDetect();\n    },\n\n\n    /**\n* clear the Hammer.gesture vars\n* this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n* to stop other Hammer.gestures from being fired\n*/\n    stopDetect: function stopDetect() {\n        // clone current data to the store as the previous gesture\n        // used for the double tap gesture, since this is an other gesture detect session\n        this.previous = Hammer.utils.extend({}, this.current);\n\n        // reset the current\n        this.current = null;\n\n        // stopped!\n        this.stopped = true;\n    },\n\n\n    /**\n* extend eventData for Hammer.gestures\n* @param {Object} ev\n* @returns {Object} ev\n*/\n    extendEventData: function extendEventData(ev) {\n        var startEv = this.current.startEvent;\n\n        // if the touches change, set the new touches over the startEvent touches\n        // this because touchevents don't have all the touches on touchstart, or the\n        // user must place his fingers at the EXACT same time on the screen, which is not realistic\n        // but, sometimes it happens that both fingers are touching at the EXACT same time\n        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n            // extend 1 level deep to get the touchlist with the touch objects\n            startEv.touches = [];\n            for(var i=0,len=ev.touches.length; i<len; i++) {\n                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));\n            }\n        }\n\n        var delta_time = ev.timestamp - startEv.timestamp,\n            delta_x = ev.center.pageX - startEv.center.pageX,\n            delta_y = ev.center.pageY - startEv.center.pageY,\n            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);\n\n        Hammer.utils.extend(ev, {\n            deltaTime : delta_time,\n\n            deltaX : delta_x,\n            deltaY : delta_y,\n\n            velocityX : velocity.x,\n            velocityY : velocity.y,\n\n            distance : Hammer.utils.getDistance(startEv.center, ev.center),\n            angle : Hammer.utils.getAngle(startEv.center, ev.center),\n            direction : Hammer.utils.getDirection(startEv.center, ev.center),\n\n            scale : Hammer.utils.getScale(startEv.touches, ev.touches),\n            rotation : Hammer.utils.getRotation(startEv.touches, ev.touches),\n\n            startEvent : startEv\n        });\n\n        return ev;\n    },\n\n\n    /**\n* register new gesture\n* @param {Object} gesture object, see gestures.js for documentation\n* @returns {Array} gestures\n*/\n    register: function register(gesture) {\n        // add an enable gesture options if there is no given\n        var options = gesture.defaults || {};\n        if(typeof(options[gesture.name]) == 'undefined') {\n            options[gesture.name] = true;\n        }\n\n        // extend Hammer default options with the Hammer.gesture options\n        Hammer.utils.extend(Hammer.defaults, options);\n\n        // set its index\n        gesture.index = gesture.index || 1000;\n\n        // add Hammer.gesture to the list\n        this.gestures.push(gesture);\n\n        // sort the list by index\n        this.gestures.sort(function(a, b) {\n            if (a.index < b.index) {\n                return -1;\n            }\n            if (a.index > b.index) {\n                return 1;\n            }\n            return 0;\n        });\n\n        return this.gestures;\n    }\n};\n\n\nHammer.gestures = Hammer.gestures || {};\n\n/**\n* Custom gestures\n* ==============================\n*\n* Gesture object\n* --------------------\n* The object structure of a gesture:\n*\n* { name: 'mygesture',\n* index: 1337,\n* defaults: {\n* mygesture_option: true\n* }\n* handler: function(type, ev, inst) {\n* // trigger gesture event\n* inst.trigger(this.name, ev);\n* }\n* }\n\n* @param {String} name\n* this should be the name of the gesture, lowercase\n* it is also being used to disable/enable the gesture per instance config.\n*\n* @param {Number} [index=1000]\n* the index of the gesture, where it is going to be in the stack of gestures detection\n* like when you build an gesture that depends on the drag gesture, it is a good\n* idea to place it after the index of the drag gesture.\n*\n* @param {Object} [defaults={}]\n* the default settings of the gesture. these are added to the instance settings,\n* and can be overruled per instance. you can also add the name of the gesture,\n* but this is also added by default (and set to true).\n*\n* @param {Function} handler\n* this handles the gesture detection of your custom gesture and receives the\n* following arguments:\n*\n* @param {Object} eventData\n* event data containing the following properties:\n* timestamp {Number} time the event occurred\n* target {HTMLElement} target element\n* touches {Array} touches (fingers, pointers, mouse) on the screen\n* pointerType {String} kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH\n* center {Object} center position of the touches. contains pageX and pageY\n* deltaTime {Number} the total time of the touches in the screen\n* deltaX {Number} the delta on x axis we haved moved\n* deltaY {Number} the delta on y axis we haved moved\n* velocityX {Number} the velocity on the x\n* velocityY {Number} the velocity on y\n* angle {Number} the angle we are moving\n* direction {String} the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT\n* distance {Number} the distance we haved moved\n* scale {Number} scaling of the touches, needs 2 touches\n* rotation {Number} rotation of the touches, needs 2 touches *\n* eventType {String} matches Hammer.EVENT_START|MOVE|END\n* srcEvent {Object} the source event, like TouchStart or MouseDown *\n* startEvent {Object} contains the same properties as above,\n* but from the first touch. this is used to calculate\n* distances, deltaTime, scaling etc\n*\n* @param {Hammer.Instance} inst\n* the instance we are doing the detection for. you can get the options from\n* the inst.options object and trigger the gesture event by calling inst.trigger\n*\n*\n* Handle gestures\n* --------------------\n* inside the handler you can get/set Hammer.detection.current. This is the current\n* detection session. It has the following properties\n* @param {String} name\n* contains the name of the gesture we have detected. it has not a real function,\n* only to check in other gestures if something is detected.\n* like in the drag gesture we set it to 'drag' and in the swipe gesture we can\n* check if the current gesture is 'drag' by accessing Hammer.detection.current.name\n*\n* @readonly\n* @param {Hammer.Instance} inst\n* the instance we do the detection for\n*\n* @readonly\n* @param {Object} startEvent\n* contains the properties of the first gesture detection in this session.\n* Used for calculations about timing, distance, etc.\n*\n* @readonly\n* @param {Object} lastEvent\n* contains all the properties of the last gesture detect in this session.\n*\n* after the gesture detection session has been completed (user has released the screen)\n* the Hammer.detection.current object is copied into Hammer.detection.previous,\n* this is usefull for gestures like doubletap, where you need to know if the\n* previous gesture was a tap\n*\n* options that have been set by the instance can be received by calling inst.options\n*\n* You can trigger a gesture event by calling inst.trigger(\"mygesture\", event).\n* The first param is the name of your gesture, the second the event argument\n*\n*\n* Register gestures\n* --------------------\n* When an gesture is added to the Hammer.gestures object, it is auto registered\n* at the setup of the first Hammer instance. You can also call Hammer.detection.register\n* manually and pass your gesture object as a param\n*\n*/\n\n/**\n* Hold\n* Touch stays at the same place for x time\n* @events hold\n*/\nHammer.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n        hold_timeout: 500,\n        hold_threshold: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                // clear any running timers\n                clearTimeout(this.timer);\n\n                // set the gesture so we can check in the timeout if it still is\n                Hammer.detection.current.name = this.name;\n\n                // set timer and if after the timeout it still is hold,\n                // we trigger the hold event\n                this.timer = setTimeout(function() {\n                    if(Hammer.detection.current.name == 'hold') {\n                        inst.trigger('hold', ev);\n                    }\n                }, inst.options.hold_timeout);\n                break;\n\n            // when you move or end we clear the timer\n            case Hammer.EVENT_MOVE:\n                if(ev.distance > inst.options.hold_threshold) {\n                    clearTimeout(this.timer);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                clearTimeout(this.timer);\n                break;\n        }\n    }\n};\n\n\n/**\n* Tap/DoubleTap\n* Quick touch at a place or double at the same place\n* @events tap, doubletap\n*/\nHammer.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n        tap_max_touchtime : 250,\n        tap_max_distance : 10,\n        doubletap_distance : 20,\n        doubletap_interval : 300\n    },\n    handler: function tapGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // previous gesture, for the double tap since these are two different gesture detections\n            var prev = Hammer.detection.previous;\n\n            // when the touchtime is higher then the max touch time\n            // or when the moving distance is too much\n            if(ev.deltaTime > inst.options.tap_max_touchtime ||\n                ev.distance > inst.options.tap_max_distance) {\n                return;\n            }\n\n            // check if double tap\n            if(prev && prev.name == 'tap' &&\n                (ev.timestamp - prev.lastEvent.timestamp) < inst.options.doubletap_interval &&\n                ev.distance < inst.options.doubletap_distance) {\n                Hammer.detection.current.name = 'doubletap';\n            }\n            else {\n                Hammer.detection.current.name = 'tap';\n            }\n\n            inst.trigger(Hammer.detection.current.name, ev);\n        }\n    }\n};\n\n\n/**\n* Swipe\n* triggers swipe events when the end velocity is above the threshold\n* @events swipe, swipeleft, swiperight, swipeup, swipedown\n*/\nHammer.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n        // set 0 for unlimited, but this can conflict with transform\n        swipe_max_touches : 1,\n        swipe_velocity : 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // max touches\n            if(inst.options.swipe_max_touches > 0 &&\n                ev.touches.length > inst.options.swipe_max_touches) {\n                return;\n            }\n\n            // when the distance we moved is too small we skip this gesture\n            // or we can be already in dragging\n            if(ev.velocityX > inst.options.swipe_velocity ||\n                ev.velocityY > inst.options.swipe_velocity) {\n                // trigger swipe events\n                inst.trigger(this.name, ev);\n                inst.trigger(this.name + ev.direction, ev);\n            }\n        }\n    }\n};\n\n\n/**\n* Drag\n* Move with x fingers (default 1) around on the page. Blocking the scrolling when\n* moving left and right is a good practice. When all the drag events are blocking\n* you disable scrolling on that area.\n* @events drag, drapleft, dragright, dragup, dragdown\n*/\nHammer.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n        drag_min_distance : 10,\n        // set 0 for unlimited, but this can conflict with transform\n        drag_max_touches : 1,\n        // prevent default browser behavior when dragging occurs\n        // be careful with it, it makes the element a blocking element\n        // when you are using the drag gesture, it is a good practice to set this true\n        drag_block_horizontal : false,\n        drag_block_vertical : false,\n        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n        // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n        drag_lock_to_axis : false\n    },\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // max touches\n        if(inst.options.drag_max_touches > 0 &&\n            ev.touches.length > inst.options.drag_max_touches) {\n            return;\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(ev.distance < inst.options.drag_min_distance &&\n                    Hammer.detection.current.name != this.name) {\n                    return;\n                }\n\n                // we are dragging!\n                Hammer.detection.current.name = this.name;\n\n                // lock drag to axis?\n                var last_direction = Hammer.detection.current.lastEvent.direction;\n                if(inst.options.drag_lock_to_axis && last_direction !== ev.direction) {\n                    // keep direction on the axis that the drag gesture started on\n                    if(Hammer.utils.isVertical(last_direction)) {\n                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n                    }\n                    else {\n                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n                    }\n                }\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                // trigger normal event\n                inst.trigger(this.name, ev);\n\n                // direction event, like dragdown\n                inst.trigger(this.name + ev.direction, ev);\n\n                // block the browser events\n                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||\n                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {\n                    ev.preventDefault();\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n* Transform\n* User want to scale or rotate with 2 fingers\n* @events transform, pinch, pinchin, pinchout, rotate\n*/\nHammer.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n        transform_min_scale : 0.01,\n        // rotation in degrees\n        transform_min_rotation : 1,\n        // prevent default browser behavior when two touches are on the screen\n        // but it makes the element a blocking element\n        // when you are using the transform gesture, it is a good practice to set this true\n        transform_always_block : false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // atleast multitouch\n        if(ev.touches.length < 2) {\n            return;\n        }\n\n        // prevent default when two fingers are on the screen\n        if(inst.options.transform_always_block) {\n            ev.preventDefault();\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                var scale_threshold = Math.abs(1-ev.scale);\n                var rotation_threshold = Math.abs(ev.rotation);\n\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(scale_threshold < inst.options.transform_min_scale &&\n                    rotation_threshold < inst.options.transform_min_rotation) {\n                    return;\n                }\n\n                // we are transforming!\n                Hammer.detection.current.name = this.name;\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                inst.trigger(this.name, ev); // basic transform event\n\n                // trigger rotate event\n                if(rotation_threshold > inst.options.transform_min_rotation) {\n                    inst.trigger('rotate', ev);\n                }\n\n                // trigger pinch event\n                if(scale_threshold > inst.options.transform_min_scale) {\n                    inst.trigger('pinch', ev);\n                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n* Touch\n* Called as first, tells the user has touched the screen\n* @events touch\n*/\nHammer.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n        // call preventDefault at touchstart, and makes the element blocking by\n        // disabling the scrolling of the page, but it improves gestures like\n        // transforming and dragging.\n        // be careful with using this, it can be very annoying for users to be stuck\n        // on the page\n        prevent_default: false\n    },\n    handler: function touchGesture(ev, inst) {\n        if(inst.options.prevent_default) {\n            ev.preventDefault();\n        }\n\n        if(ev.eventType == Hammer.EVENT_START) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n\n/**\n* Release\n* Called as last, tells the user has released the screen\n* @events release\n*/\nHammer.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n// Expose Hammer to the global object\nwindow.Hammer = Hammer;\n\n// requireJS module definition\nif(typeof window.define === 'function' && window.define.amd) {\nwindow.define('hammer', [], function() {\n        return Hammer;\n    });\n}\n\n})(window);\n"
