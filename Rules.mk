# This makefile is largely inspired from "Recursive Make Considered
# Harmful" [Miller, 1997] and from "Implementing non-recursive make"
# [van Bergen, 2002] # <http://evbergen.home.xs4all.nl/nonrecursive-make.html>.
#
# This file is the entry point for make. It defines global variables
# used elsewhere in the source tree, and sources the src/Makefile.config
# which has been generated by configure.ml.
#
# It the visits each subdirectory (among those declared in the
# $(MODULES) variable below) and includes the file Rules.mk when it
# exists. Each Rules.mk can use:
# * the $(d) variable, whose value is either empty (at the root of the
#   source tree), or contains the path of the including directory
#   relative to the top of the source tree; and
# * the $(mod) variable, which contains the name of the directory being
#   visited.
#
# In other words, at the top of src/Patoline/Rules.mk, $(d) is "src/"
# and $(mod) is "Patoline".
#
# Each Rules.mk is expected to change the value of $(d) for its own
# paperwork, but it must be reset to the previous value at the end of
# the file.
#
# See for example the beginning and the end of src/Patoline/Rules.mk,
# which look like:
# * at the top:  d := $(if $(d),$(d)/,)$(mod)
# * at the end:  d := $(patsubst %/,%,$(dir $(d)))
#
# This implementation uses GNU Make $(dir) and $(patsubst) functions,
# which remove the stack-like trick used in [van Bergen]. This requires
# that $(d) MUST NOT end with a trailing slash.
#
# Beware that although each Rules.mk lives in its own directory, all
# paths must be written relatively to the top of the source tree. For
# example, the file "src/Drivers/DriverGL/Rules.mk" must refer to
# "src/Drivers/DriverGL/DriverGL.cmxa" using the string
# "$(d)/DriverGL.cmxa" and not simply "DriverGL.cmxa". The latter would
# be interpreted as <patoline_source_tree>/DriverGL.cmxa (where
# <patoline_source_tree> is the toplevel directory, where the current
# makefile lives).
#
# CLEANING
# ========
#
# Each Rules.mk can use variables defined here before the "Visit
# subdirectories" part. It is also expected to expand (but NOT replace)
# the value of $(CLEAN) and $(DISTCLEAN) variables with paths of files
# which must be respectively cleaned by "make clean" (e.g., object files,
# binaries) or by "make distclean" (e.g., dependencies files ending in
# ".depends", or src/Makefile.config).
#
# Each Rules.mk is responsible for its own cleaning. You can use:
#   darcs status --boring | grep "^a"
# after a "make distclean" to check that no generated file remains after
# a distclean.
#
#
# INSTALLING
# ==========
#
# Create your own install-something in your Rules.mk, and add
# "install-something" to the $(INSTALL_TARGETS) variable.
#
# Use the "install" command in your rules.
#
#
# COMMON PITFALLS
# ===============
#
# It is usually a WRONG idea to use "./" or "../" in Rules.mk, since
# make won't simplify them to get canonical filenames when parsing
# rules. Better define a global $(SOMETHING_DIR) from an upper-level
# Rules.mk.
#
# Variables inside make rules are not expanded immediately: you cannot
# use $(d) there, since its value will probably be different from what
# you expect.
#
# When building both bytecode and native code from the same .ml source
# file, which has no corresponding .mli, both ocamlc and ocamlopt output
# a .cmi file. This means that they must not be run in parallel,
# otherwise we get a corrupted .cmi file. One can prevent this from
# happening by making the .cmx native object depend on the .cmo object.
# (The converse dependency is a wrong idea, because on some platforms we
# cannot build the .cmx file.)
#
#
# OUTPUT TARGET SPECIFIC VARIABLES
# ================================
#
# Unlike [van Bergen], we do not use target-specific variables, which
# have a blocker design flaw: their get inherited by prerequisites. GNU
# Make 3.82 introduced the "private" modifier on variable declarations,
# which exactly suppresses this inheritance. Yet, as long as GNU Make
# 3.82 has not made it to Debian (testing) and Ubuntu, we won't use this
# useful feature.


# Import variables computed by configure.ml
ifneq "$(wildcard src/Makefile.config)" ""
  include src/Makefile.config
endif

# Useful directories, to be referenced from other Rules.ml
FONTS_DIR := Fonts
TOOLS_DIR := Tools
FORMAT_DIR := Format
HYPHENATION_DIR := Hyphenation
EDITORS_DIR := editors

# Compilers and various tools
OCAML := ocaml
OCAMLFIND := ocamlfind
OCAMLC = ocamlfind ocamlc $(if $(OCPP),-pp '$(OCPP)',)
OCAMLOPT_SIMPLE = ocamlfind ocamlopt
OCAMLC_SIMPLE = ocamlfind ocamlc
OCAMLOPT_NOPP = $(OCAMLOPT_SIMPLE) -intf-suffix .cmi
OCAMLOPT_NOINTF = $(OCAMLOPT_SIMPLE) $(if $(OCPP),-pp '$(OCPP)',)
OCAMLOPT = $(OCAMLOPT_NOINTF) $(if $(OCPP),-pp '$(OCPP)',) -intf-suffix .cmi
OCAMLDEP = ocamlfind ocamldep $(if $(OCPP),-pp '$(OCPP)',) $(OCAMLDEPEXTRAS)
OCAMLMKLIB = ocamlfind ocamlmklib
OCAMLDOC = ocamlfind ocamldoc $(if $(OCPP),-pp '$(OCPP)',)
OCAMLYACC = ocamlyacc
OCAMLLEX = ocamllex
FILE_TO_STRING = $(TOOLS_DIR)/file_to_string

export OCAML OCAMLC OCAMLOPT OCAMLDEP OCAMLMKLIB

# Environment variable for ocamlfind to search for local package
# and ignore duplicate definition due to previous installation
OCAMLPATH_SAVE := $(OCAMLPATH)
OCAMLPATH = $(SRC_DIR):$(OCAMLPATH_SAVE)
export OCAMLPATH
OCAMLFIND_IGNORE_DUPS_IN=$(shell ocamlfind printconf destdir)
export OCAMLFIND_IGNORE_DUPS_IN

# Sanity tests, empty for now
.PHONY: check
check:

# The following declarations are necessary to make $(CLEAN) and
# $(DISTCLEAN) immediate variables (i.e., right hand side of the
# declaration is expanded immediately). Otherwise, Rules.mk cannot use
# extend it with the "+=" operator, along with $(d) on the right-hand
# side.
CLEAN :=
CLEANR :=
DISTCLEAN :=
DISTCLEANR :=

-include Rules.clean
clean:
	rm -f $(CLEAN)
	rm -rf $(CLEANR)

distclean: clean
	rm -f $(DISTCLEAN)
	rm -rf $(DISTCLEANR)
	rm -f $(FILE_TO_STRING)

# Visit subdirectories
MODULES := src Hyphenation editors Fonts Accessoires
d :=
$(foreach mod,$(MODULES),$(eval include $$(mod)/Rules.mk))

install: install-bindir
install-bindir:
	install -m 755 -d $(DESTDIR)/$(INSTALL_BIN_DIR)

# Prevent make from removing intermediate build targets
.SECONDARY:	$(CLEAN) $(DISTCLEAN)

# Common rules for OCaml
# Force INCLUDES to be an immediate variable
INCLUDES:=

%.ml.depends: %.ml
	$(ECHO) "[DEP] $@"
	$(Q)$(OCAMLDEP) $(INCLUDES) -I $(<D) $< > $@

%.mli.depends: %.mli
	$(ECHO) "[DEP] $@"
	$(Q)$(OCAMLDEP) $(INCLUDES) $< > $@

%.cmi: %.mli %.ml.depends
	$(ECHO) "[BYT] $@"
	$(Q)$(OCAMLC) $(OFLAGS) $(INCLUDES) -o $@ -c $<

%.cmo: %.ml %.ml.depends
	$(ECHO) "[BYT] $@"
	$(Q)$(OCAMLC) $(OFLAGS) $(INCLUDES) -o $@ -c $<
%.cmx: %.cmo

%.cmx: %.ml %.ml.depends
	$(ECHO) "[OPT] $@"
	$(Q)$(OCAMLOPT) $(OFLAGS) $(INCLUDES) -o $@ -c $<

%: %.cmo
	$(ECHO) "[LNK] $@"
	$(Q)$(OCAMLC) -linkpkg $(INCLUDES) -o $@ $<

%: %.cmx
	$(ECHO) "[LNK] $@"
	$(Q)$(OCAMLOPT) -linkpkg $(INCLUDES) -o $@ $<

%.ml: %.mly
	$(ECHO) "[YAC] $@"
	$(Q)$(OCAMLYACC) $<

%.ml: %.mll
	$(ECHO) "[LEX] $@"
	$(Q)$(OCAMLLEX) -q $<

$(FILE_TO_STRING): $(FILE_TO_STRING).ml
	$(ECHO) "[GEN] $@"
	$(Q)$(OCAMLC) -package bytes $< -o $@
